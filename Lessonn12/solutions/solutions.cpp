#include <iostream>
using namespace std;
int fact(int n)
{
	// Факториел от 0 е 1
	// Това е дъното на рекурсията и в края на извикването програмата ще стигне до нея
	if (n == 0) return 1;

	// n! = n * (n-1)!
	// a (n-1)! ще го сметнем със същата функция, с която смятаме n!
	return n * fact(n - 1);
}

/// Бавна рекурсивна функция за намиране на n-тото число на Фибоначи
int fib(int n)
{
	// Дъна на рекурсията
	if (n == 0) return 0;
	if (n == 1) return 1;

	// Едно число на фибоначи е равно на сумата от предишните две
	return fib(n - 1) + fib(n - 2);
}


/// Намира n - тото число на Фибоначи с линейна рекурсия(бързо)
int fib(int first, int second, int next, int n, int i)
{

	if (n == 0) return 0;
	if (n == 1) return 1;
	if (i == n) return second;

	return fib(second, next, second + next, n, i + 1);
}
/// Помощна функция за смятане на числата на Фибоначи
int fibFast(int n)
{
	return fib(0, 1, 1, n, 1);
}

/// Рекурсивна функция за принтиране на елементите на масив
void print(int * arr, int sz)
{
	// Ако масива няма елементи, не принтираме нищо
	if (sz == 0) return;

	// Изкарваме първия елемент на масива ...
	cout << *arr << " ";
	//cout << arr[0] << " "; // работи по същия начин

	// ... и викаме същата функция, да ни принтира масива след този елемент
	// Указател към първия елемент на масива ще е arr+1 (пропускаме елемента, на който сме в момента),
	// и е с един елемент по-малко (sz-1).
	print(arr + 1, sz - 1);
}

/// Рекусивна функция, която прочита n елемента от екрана и ги записва в масив
void _read(int * arr, int n, int i)
{
	// Ако i == n, значи сме прочели n елемента. Спираме
	if (i == n) return;

	// Ако не, то прочитаме елемент и го слагаме в масива
	cin >> *arr;

	// Прочитаме пстаналите елементи с функцията _read и ги поставяме в масив с указател към първия елемент arr+1,
	// брой елементи n и следващ елемент i+1
	_read(arr + 1, n, i + 1);
}

/// Функция, която прочита от екрана цели числа и ги записва в масива arr
void read(int * arr, int sz)
{
	// Имаме размера на масива, но не и колко елементи ще прочетем
	int realSize; // Реалният брой на елементите
	cin >> realSize;

	// Ако трябва да прочетем повече елементи, отколкото е голям масива
	if (realSize > sz)
	{
		cout << "ARRAY IS SHORTER THAN DATA" << endl;
		return;
	}
	// Викане на рекурсивната функция, която ще прочете масива
	_read(arr, realSize, 0);
}

/// Рекурсивна функция, която проверява дали едно цяло число е степен на двойката
bool isPowerOfTwo(int n)
{
	// Дъно на рекурсията
	// След няколко извиквания ще стигнем до n == 1
	if (n == 1) return true;
	
	// Едно число е степен на двойката ако то се дели на 2 без остатък
	// И като се раздели на 2, това число също трябва да е степен на двойката 
	return n % 2 == 0 && isPowerOfTwo(n/2);
}

int main()
{
	// Проверка дали едно число е степен на двойката
	int n = 8;
	cout << (isPowerOfTwo(n) ? "YES" : "NO") << endl;

	cout << fact(n) << endl;
	cout << fib(n) << endl;
	cout << fibFast(n) << endl;

	/// ОПЕРАЦИИ С МАСИВИ

	const int MAX_SIZE = 4;
	int arr[MAX_SIZE] = { 1, 2, 3, 4 };

	// Прочитаме масива с най-много MAX_SIZE елементи
	read(arr, MAX_SIZE);

	// Принтиране на MAX_SIZE елементи на масива
	print(arr, MAX_SIZE);

	return 0;
}
